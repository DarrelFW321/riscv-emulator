<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RISC-V Emulator Reference</title>
<style>
  body {
    font-family: 'Segoe UI', sans-serif;
    margin: 40px;
    line-height: 1.6;
    background: #fafafa;
    color: #222;
  }
  h1, h2, h3 {
    color: #2b5fad;
  }
  code {
    background: #eee;
    padding: 2px 4px;
    border-radius: 4px;
  }
  pre {
    background: #f3f3f3;
    padding: 12px;
    border-radius: 6px;
    overflow-x: auto;
    border-left: 4px solid #2b5fad;
  }
  table {
    border-collapse: collapse;
    margin-top: 10px;
    width: 100%;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 6px 10px;
    text-align: left;
  }
  th {
    background: #e5e5e5;
  }
</style>
</head>
<body>

<h1>RISC-V Emulator Reference</h1>
<p>This document describes the supported instruction set and runtime behavior for the custom WebAssembly RISC-V emulator by <strong>Darrel Wihandi</strong>.</p>

<hr>

<h2>Quick Start</h2>
<p>To run your first RISC-V program:</p>
<ol>
  <li>Paste the following into the emulator’s <strong>Program Input</strong> area.</li>
  <li>Click <strong>Load</strong> → <strong>Step</strong> or <strong>Run</strong> to execute.</li>
  <li>Inspect registers (<code>x0–x31</code> or ABI names like <code>a0, sp</code>) and memory updates.</li>
</ol>

<pre><code>ADDI x1, x0, 5
ADDI x2, x0, 10
JAL x5, sum_func
SW x3, 3(x1)
ECALL

sum_func:
  ADD x3, x1, x2
  JALR x0, 0(x5)
</code></pre>

<ul>
  <li><code>x1 = 5</code>, <code>x2 = 10</code></li>
  <li><code>x3 = 15</code> after <code>sum_func</code></li>
  <li>Stored to <code>mem[x1+3]</code> and halts on <code>ECALL</code></li>
</ul>

<hr>

<h2>Memory Model</h2>
<ul>
  <li><strong>Address Range:</strong> 0x0000–0x0FFF (4096 bytes, 1024 words)</li>
  <li><strong>Word Size:</strong> 4 bytes</li>
  <li><strong>Alignment:</strong> <code>LH/LHU</code> → 2-byte aligned; <code>LW/SW</code> → 4-byte aligned.</li>
  <li><strong>Out-of-Range:</strong> Accesses beyond 0x0FFF show <code>[Warning] Memory access out of bounds</code>.</li>
  <li><strong>Stack Pointer (sp):</strong> Initialized to the <em>end of memory</em> (0x0FFC). The stack grows downward from this region.</li>
</ul>

<hr>

<h2>Registers</h2>
<ul>
  <li>32 general-purpose 32-bit registers (<code>x0</code>–<code>x31</code>)</li>
  <li><code>x0</code> is hard-wired to 0 and cannot be written.</li>
  <li><strong>Program Counter (PC):</strong> 32-bit; increments by +4 unless modified by a branch/jump.</li>
  <li><strong>ABI Aliases:</strong> The emulator fully supports standard ABI register names:</li>
</ul>

<table>
<tr><th>ABI Name</th><th>x#</th><th>Description</th></tr>
<tr><td>zero</td><td>x0</td><td>Constant zero</td></tr>
<tr><td>ra</td><td>x1</td><td>Return address</td></tr>
<tr><td>sp</td><td>x2</td><td>Stack pointer (initialized to 0x0FFC)</td></tr>
<tr><td>gp</td><td>x3</td><td>Global pointer (initialized to 0x0800)</td></tr>
<tr><td>tp</td><td>x4</td><td>Thread pointer</td></tr>
<tr><td>t0–t6</td><td>x5–x7, x28–x31</td><td>Temporaries</td></tr>
<tr><td>s0–s11</td><td>x8–x9, x18–x27</td><td>Saved registers</td></tr>
<tr><td>a0–a7</td><td>x10–x17</td><td>Function arguments / return values</td></tr>
</table>

<p>Use either numeric (<code>x5</code>) or ABI (<code>t0</code>) notation — both are supported interchangeably in this emulator.</p>

<hr>

<h2>Pseudo-Instructions</h2>
<p>The emulator expands several pseudo-instructions automatically during load:</p>
<table>
<tr><th>Pseudo</th><th>Equivalent Expansion</th></tr>
<tr><td><code>LI rd, imm</code></td><td><code>ADDI rd, x0, imm</code></td></tr>
<tr><td><code>MV rd, rs</code></td><td><code>ADDI rd, rs, 0</code></td></tr>
<tr><td><code>J label</code></td><td><code>JAL x0, label</code></td></tr>
<tr><td><code>JR rs</code></td><td><code>JALR x0, 0(rs)</code></td></tr>
<tr><td><code>RET</code></td><td><code>JALR x0, 0(x1)</code></td></tr>
<tr><td><code>LA rd, label</code></td><td>Resolves label to memory address at runtime</td></tr>
</table>

<hr>

<h2>Supported Instructions</h2>
<p>Implements the <strong>RV32I base integer instruction set</strong> as defined by the RISC-V Foundation.</p>

<p>For detailed bit fields and encodings, see the <a href="RISC-V Reference Card1.pdf" target="_blank"><strong>Official RISC-V Reference Card (PDF)</strong></a>.</p>

<p>The following tables summarize the categories supported:</p>

<ul>
  <li><strong>Arithmetic & Logic:</strong> ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, SLT, SLTU, plus immediate variants (ADDI, ANDI, etc.)</li>
  <li><strong>Load/Store:</strong> LB/LBU, LH/LHU, LW, SB, SH, SW</li>
  <li><strong>Branch/Jump:</strong> BEQ, BNE, BLT, BGE, BLTU, BGEU, JAL, JALR</li>
  <li><strong>Upper-Immediate:</strong> LUI, AUIPC</li>
  <li><strong>System:</strong> ECALL (halts program)</li>
</ul>

<hr>

<h2>Execution Model</h2>
<ul>
  <li>Each instruction advances the PC by +4 unless modified by a branch or jump.</li>
  <li>Execution occurs step-by-step or continuously.</li>
  <li>Labels are resolved to byte addresses during load.</li>
  <li><strong>x0</strong> is always 0, enforced every step.</li>
</ul>

<hr>

<h2>Author & Credits</h2>
<p><strong>Darrel Wihandi</strong><br>
RISC-V Web Emulator Project<br>
Built with C++ (Emscripten) + HTML/JS Frontend</p>

<p>Based on the <a href="RISC-V Reference Card1.pdf" target="_blank"><strong>RISC-V Reference Card (RV32I Base)</strong></a> by the RISC-V Foundation.</p>

<p>Last Updated: <script>document.write(new Date().toLocaleDateString())</script></p>

</body>
</html>
